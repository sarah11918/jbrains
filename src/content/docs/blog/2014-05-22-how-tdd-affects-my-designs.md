---
title: "How TDD Affects My Designs"
date: 2014-05-22 14:34 -0300
tags: 
---
I [have](https://twitter.com/jbrains/status/205679396508549120) [written](https://twitter.com/jbrains/status/468555663929769984) [elsewhere](https://twitter.com/jbrains/status/314574600069607424) that people, not rules, do things. I have written this in exasperation over some people claiming that TDD has ruined their lives in all manner of ways. Enough!

People, not rules, design software systems. People decide which rules to follow and when. The (human) system certainly influences them, but ultimately, the people decide. In particular, people, not TDD, decide how to design software systems. James Shore has recently written ["How Does TDD Affect Design?"](https://link.jbrains.ca/1ktgs6B) to offer his opinion, in which he leads with this.

> I’ve heard people say TDD automatically creates good designs. More recently, I’ve heard David Hansson say it creates design damage. Who’s right?
>
> Neither. TDD doesn’t create design. You do.

I agree. Keith Braithwaite responded in a comment with this.

> TDD does not by itself create good or bad designs, but I have evidence (see ["Complexity and Test-First 0"](https://link.jbrains.ca/1ktgHPg)) suggesting that it does create different designs.

Keith's comment triggered me to think about how practising TDD has affected the way I design software systems, of which this article represents a summary. I might add more to this list over time. If you've noticed an interesting pattern in your designs that you attribute to your practice of TDD, then please share that in the comments.

**More value objects, meaning objects with value-equality over identity-equality**. I do this more because I want to use `assertEquals()` a lot in my tests. This also leads to smaller functions that return a value object. This also leads specifically to more functions that return a value object signifying the result of the function, where I might not have cared about the result before. Sometimes this leads to unnecessary code, and when it does, I usually find that I improve the design by introducing a missing abstraction, such as an event.

**More fire-and-forget events**. I do this more because I want to [keep irrelevant details out of my tests](/permalink/what-your-tests-dont-need-to-know-will-hurt-you). Suppose that function X should cause side-effect Y. If I check for side-effect Y, then I have to know the details of how to product side-effect Y, which usually leads to excessive, duplicate setup code in both X's tests and Y's tests. Not only that, but when X's tests fail, I have to investigate to learn whether I have a problem in X or Y or both. Whether I approach this mechanically (remove duplication in the tests) or intuitively (remove irrelevant details from the tests), I end up introducing event Z and recasting my expectations of X to "X should fire event Z". This kind of thing gives many programmers the impression of "testing the implementation", whereas I interpret this as "defining the essential interaction between X and the rest of the system". The decision to make function X fire event Z respects the Open/Closed Principle: inevitably I want X to cause new side-effects A, B, and C. By designing function X as a source for event Z, I can add side-effects A, B, and C as listeners for event Z without changing anything about function X. This leads me to see the recent (as of 2014) trend towards Event Sourcing as a TDD-friendly trend.

**More interfaces in languages that have interface types**. In the old days, we had to introduce interfaces (in Java/C#) in order to use the cool, new dynamic/proxy-based mocking libraries, like EasyMock and JMock. Since the advent of bytecode generators like `cglib`, we no longer need to do this, but my habit persists of introducing interfaces liberally. Many programmers complain about having only one implementation per interface, although I still haven't understood what makes that a problem. If the language forces me to declare an interface type in order to derive the full benefits of abstraction, then I do it. At least it encourages me to organize and document essential interactions between modules in a way that looser languages like Ruby/Python/PHP don't. (Yes, we *can* implement interfaces in the duck-typing languages, but Java and C# force us to make them a separate type if we want to use them.) Moreover, the test doubles themselves act as additional implementations of the interfaces, which most detractors fail to notice. They might argue that I overuse interfaces, but I argue that they underuse them. Interfaces provide an essential service: **they constrain and clarify the client's interaction with the rest of the system**. [Most software flaws that I encounter amount to muddled interactions&mdash;usually misunderstood contracts&mdash;between modules](https://bit.ly/QWK7do). I like the way that the interfaces remind me to define and *refine* the contracts between modules.

**Immutability**. As functional programming languages have become more popular, I've noticed more talk about mutability of state, with an obvious leaning towards immutability. In particular, not only do I find myself wanting functions more often to return value objects, but specifically *immutable* value objects. Moreover, thinking about tests encourages me to consider the pathological consequences of mutability. This happened recently when I wrote ["The Curious Case of Tautological TDD"](/permalink/the-curious-case-of-tautological-tdd). Someone responded to the code I'd written pointing out a problem in the case of a mutable `Cars` class. I had so long ago decided to treat all value objects as immutable that I'd even forgot that the language doesn't naturally enforce that immutability. I've valued immutability for so long that, for me, it goes without saying. I reached this point after writing too many tests that only failed when devious programmers take advantage of unintended mutability, such as when a function returns a Java `Collection` object. I went through a phase of ensuring that I always returned an unmodifiable view of any `Collection`, but after a while, I simply decided to treat every return value as immutable, for the sake of my sanity. Functional languages push the programmer towards more enforced immutability, and even the eradication of state altogether. I feel like my experience practising TDD in languages like Java and Ruby have prepared me for this shift, so it already feels quite natural to me; on the contrary, it annoys me when I have to work in a language that doesn't enforce immutability for me.

How has TDD affected the way you design? or, perhaps more importantly, what about the way TDD might affect your designs makes you uneasy about trying it? I might have some useful advice for you.

