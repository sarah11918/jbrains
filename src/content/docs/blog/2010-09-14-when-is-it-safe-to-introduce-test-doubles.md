---
date: 2010-09-14
title: "When is it safe to introduce test doubles?"
---
<p>I recently read <a href="https://tinyurl.com/23yh3q">this article at mockobjects.com</a> and it reminded me of advice I give when I teach people about test doubles.</p>
<p>At some point after you learn how to use test doubles, and perhaps dabble with JMock or Mocha, you notice that you&#8217;re using test doubles <em>everywhere</em>. With any luck, you notice it, stand back, scratch your head, then wonder, &#8220;What exactly am I testing here?&#8221; If you&#8217;ve reached that stage, then you&#8217;re ready for this advice.</p>
<p>First, remember that everything in your system is either a Service, Entity or Value. I didn&#8217;t make those names up: I learned them from Eric Evans in Domain-Driven Design.</p>
<p>A <em>value</em> has no lifecycle, is usually immutable and behaves with value semantics. This last point mostly means that &#8220;equals&#8221; depends on the value and not the location in memory. Strings, numbers, points, lists, monetary amounts, intervals, instants in time, these are values.</p>
<p>An <em>entity</em> has a lifecycle, is usually persisted, and behaves with ID semantics. That means that two entities can look the same by value, but represent different things, and therefore aren&#8217;t equal. Think of George Foreman&#8217;s kids, all named George. If your system only stores the child&#8217;s name and its parents&#8217; names, then all those Georges look the same, but each is unique as a snowflake. Entities often use values. People, accounts, banks, transactions, these are entities.</p>
<p>A <em>service</em> co-ordinates work and provides an <span class="caps">API</span> for applications to use it. A service is transient, can be pluggable and is often best when stateless. The notion of equality doesn&#8217;t much make sense for a service, and in many applications, one instance of a service is enough. (That doesn&#8217;t mean services should be singletons in the Gang of Four sense! They might be singletons in the Spring dependency injection container sense.) Services mostly figure out which entities need changing or retrieving, then either change or retrieve them. Transfer funds, deposit, withdraw, post interest, these are services.</p>
<p>Now that we have a common language that&#8217;s probably wrong, but suitable enough for the current purpose, here is the advice I have to offer.</p>
<blockquote>
<p>Never mock values, sometimes mock entities, but mock services freely.</p>
</blockquote>
<p>That&#8217;s the version that&#8217;s easy to remember. Here&#8217;s the longer answer.</p>
<p>If you want to mock a value, then you&#8217;re not using it as a value, or your &#8220;value&#8221; is really trying to be an entity, or worse, a service. Values just are. They don&#8217;t persist themselves, they don&#8217;t find themselves&#8230; you just instantiate them, calculate with them, then throw them away. Entities will typically hold onto them, and when entities persist, the values go with them, but typically, that&#8217;s the entity&#8217;s concern, and not the value&#8217;s. A value should be so simple that there&#8217;s no benefit to mocking them. You should have no test doubles for values. If you do, it&#8217;s time to uncover what mislaid responsibility your value has, extract it out, then try again.</p>
<p>You might want to mock an entity, but more likely you want to mock how you got the entity. Again, I use the term I learned from Evans: Repository. A repository is a place to look up and store entities. A repository is a service for keeping track of entities. Most of the time, I should be able to instantiate an entity and use it, so there&#8217;s no need to use a test double in its place. Typically, when you think you want to mock an entity, first try mocking the repository from whence it came.</p>
<p>Services, you can mock with impunity. In fact, the only time not to mock a service is when you&#8217;re testing the service. Since services are typically interfaces and pluggable, you&#8217;ll want to use test doubles when you test how the application uses the service, or how a service uses another service. Since services tend to use repositories, entities and values, when you test the service, you&#8217;ll likely use test doubles for the repositories, but not for the entities nor the values.</p>
<p>So that&#8217;s a summary of when I mock what. Of course, given that &#8220;mock&#8221; makes a great verb, and given the history of the term, I used mock in the foregoing mainly as a general term for &#8220;substituting a test double&#8221;, which I generally don&#8217;t like to do. I apologize for that. If this were going in a book, I&#8217;d be far more careful. There are several types of test double: mock, spy, stub, fake, dummy&#8230; <a href="https://legacy.thecodewhisperer.com/post/1121571119/when-to-fake-when-to-mock">I once wrote about when to fake and when to mock</a>, so read that if you&#8217;re confused about how to use the different kinds of test doubles.</p>
<p>I hope you found this useful, and if you didn&#8217;t, tell me why and I&#8217;ll find a way to make it up to you.</p>
