---
title: 'Evolutionary Design: Beyond the Basics'
---

You’ve practised evolutionary design for a few months (or more) on a professional project and you feel stuck or you’re facing complex tradeoff decisions that you’re not sure how to make. If this sounds like you, then you’re ready for this course.

This is **not*** an introduction to test-driven development (TDD), but rather a chance to overcome difficulties associated with becoming comfortable guiding designs to evolve. In this course, we discuss the more complex tradeoff decisions involved in making evolutionary design a core, everyday programming practice. You’ll learn how to start to make the design flex, how to balance production with protecting your production capacity, and how to expand your view from the elements of simple design to higher-level principles of modularity.

If you need an introduction to TDD and evolutionary design, I offer [the world’s best](/training/course/worlds-best-introduction-to-tdd/).

## Audience

Any programmer who has practised TDD in a professional environment for at least a few months.

## Key Topics

- Shifting attention from behavior mistakes to design mistakes.
- How the L and D in SOLID might be all you really need.
- Balancing customer tests (BDD) with programmer tests (TDD).
- Taming mock object madness!
- Breaking through your refactoring rut.
- Client-First Design with (or without!) Test Doubles.
- The Universal Architecture and how architecture relates to design.
- Deciding when to introduce relentlessly tiny steps.
- Guiding your colleagues to buy into guiding the design to evolve.
- Patterns of writing tests: which ones, when, and why?
- Exploring how evolutionary design differs in procedural, object-oriented, and functional programming.
- Learning to trust the habits you’ve built.

## Activities

- Build features in a small, simple command-line text UI application.
- Practise microcommitting, Inbox Technique, and Monotasking.
- Engage in spirited group discussions about design decisions, principles, and approaches.
- Practise refactoring in relentlessly tiny steps.
- Ensemble programming (also known as mob programming).

## Preparation

Participants need the following to attend this course.

- A working software development environment in your preferred programming language, including a personal version control system, such as git.
- Something to write with, and something to write on. I suggest index cards or sticky notes and a notebook.

## Remote Training Preparation

Please do the following at least one day before the course is scheduled to start.

- Upgrade Zoom to the most recent version.
- Check audio, video, and screen sharing on Zoom.

## Delivery Options

### Live/Remote Private Course

The **standard course** runs as **6 sessions of 1/2 day each** scheduled within a 2-week period. The course is suitable for groups up to 12 people. Larger groups should run the course multiple times.

Add **team working sessions** to your course in order to better support teams working together during the course. During the 1/2-day team working sessions, we practise the techniques of the course using ensemble/mob programming. In these sessions, teams have the opportunity to rescue their legacy code with my guidance and support.

It is also recommended to add **follow-up working sessions** to be scheduled 1 month, 3 months, and 6-12 months after the course ends, as a way to support the group as they apply what they’ve learned to their daily work.

[Start the booking process](/training/book/) for your live/remote course.

### Join a Public Course

[Browse the upcoming course calendar](/training/upcoming-public-courses/) to see which public courses are currently available. You’ll be able to subscribe there to be notified when new courses are scheduled.